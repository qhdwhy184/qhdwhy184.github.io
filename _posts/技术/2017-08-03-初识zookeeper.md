---
layout: post
title: 初识zookeeper
category: 技术
tags: zookeeper
keywords: zookeeper
description: 
---

### 初识zookeeper

1. zookeeper从何而来 - zookeeper最早起源于雅虎研究院的一个研究小组，yahoo很多大型系统需要一个类似的系统进行分布式协调。为解决分布式协调系统的单点问题。雅虎内部很多项目都是以动物的名字来命名的，zookeeper（动物园管理员）就是设计用来管理这些分布式组件的。
2. zookeeper基本概念
	- 集群角色 
		- leader - 提供读、写服务。
		- follower - 读服务。
		- observer - 读服务，不参与leader选举，不参与写操作的“过半写成功”策略，目的是提升系统的读性能。
	- Session
		- 客户端服务器之间建立TCP长连接 - 发送请求和接受响应，接受watch事件的通知。
		- sessionTimeOut - 当客户端连接意外断开后，只要在sessionTimeOut时间内重新连接，那么之前创建的session仍然有效。
	- 数据节点（ZNode）
		- ZNode - 数据模型中的数据单元。数据模型是一棵树，由‘/’分隔的路径就是一个Znode。例如，/foo,/foo/path
                                                         
		- 持久节点 - 需要主动移除。
		- 临时节点 - 生命周期和session绑定，一旦session结束，此客户端创建的所有临时节点都将被移除。只能作为叶子节点。
		- ZNode的SEQUENTIAL属性 - 在带有此属性的节点被创建时，节点名后自动追加一个整形数字。这个数字是一个由其父节点维护的自增数字。
		- watcher - 用户可以在指定节点上注册watcher以监听某些特定事件。
3. zookeeper解决的问题：
	- 解决单点问题
	- 大吞吐
	- 顺序访问控制
4. 设计目标
	- 简单的数据模型：使分布式程序通过一个共享的、树形结构的名字空间来相互协调
		- 树形结构，由一系列数据节点组成（ZNode）
	- 可以构建集群
		- 每台机器都在内存中维护着当前服务器的状态。只要集群中超过一半的机器能够正常工作整个集群就能够正常对外服务。
		- 自动重连 - zookeeper客户端通过TCP与某台机器建立连接，一旦断开，客户端会自动重连到集群中其他机器。
	- 顺序访问
		- 全局唯一的递增编号 - 客户端每个更新请求都会分配一个全局唯一的递增编号，确定所有事务的先后顺序。
	- 高性能
		- 全量数据储存在内存中，以此实现高吞吐，低延迟。直接服务于非事务请求，适用于读操作为主的应用场景。3台机器的zookeeper集群，100%读请求场景压测结果12-13W QPS。


5. 典型应用场景
	- 数据的发布订阅 - 配置中心，通过watcher在数据变更时向订阅者推送消息。例如mtconfig。
	- 负载均衡 - 动态DNS服务，例DDNS
	- 命名服务 - 通过顺序节点来作为全局唯一ID
	- 分布式协调/通知 - 
	- master选举 - 利用zookeeper的强一致性，无法重复创建一个已经存在的数据节点Znode，那么能够成功创建节点的机器成为master，并且通过watcher可以感知master是否正常。（通过数据库插入主键方式实现如果master挂掉无法感知）
	- 分布式锁 （可通过数据库锁机制实现，但是会增加数据库压力，绝大多数分布式系统的性能瓶颈都在数据库）
		- 排他锁 - 通过创建临时节点。成功创建 - 获得锁。任务完成删掉节点或程序挂掉节点被移除 - 释放锁。
		- 共享锁 - 通过创建带有读写标识的临时顺序节点。
			- 写请求 - 若所创建的节点编号是最小的，那么获得写锁，否则等待。 
			- 读请求 - 若所创建节点编号最小或其它更小编号的节点均为读请求，那么获得锁，否则等待。
	- 分布式队列 
		- FIFO队列 - 临时顺序节点
		- Barrier队列 - 父节点存储需要资源数n，通过临时子节点个数统计当前ready的资源数。
	- 大型分布式系统中的应用 - 
		- hadoop 为解决resourceManager 单点问题，进行主备切换。
			- 通过创建临时锁节点选出master。
			- 通过watcher监控单点故障。
			- 通过Znode的ACL信息独占根节点避免“脑裂”。 
		- HBase
		- Kafka
		- Dubbo RPC框架
		- JStorm 实时计算引擎
6. 系统模型
	- 数据模型
		- 树 
			- Znode 每个节点上都可以保存数据，同时还可以挂载子节点
		- 事务 - 对于每一个事务请求，Zookeeper都会为其分配一个全局唯一的事务ID。ZXID，通常是一个64位的数字。
			- 在zookeeper中，事务指能改变Zookeeper状态的操作。
				- 节点创建，删除
				- 数据节点内容更新
				- 客户端Session创建与失效；
	- 节点特性 - 持久节点，临时节点，顺序节点三类。具体创建中需组合使用，可以组合出以下类型
		- 持久节点
		- 持久顺序节点
		- 临时节点
		- 临时顺序节点
	- 状态信息，例如
		- 事务ID
		- 版本信息
		- 子节点个数
	- 版本 - 与传统软件版本不同，表示的是对数据节点的数据内容，子节点列表，节点ACL信息的修改次数。节点创建后 Version=0，表示该节点数据内容的变更次数，强调变更次数，即使两次更新内容一致版本也会变化。
		- 保证分布式数据的原子性操作。【JDK中乐观锁CAS实现机制 - 对于值V，每次更新前都会比对其值是否是预期值A，只有符合预期，才会将V原子化地更新到值B。】与CAS实现机制相同，更新时会比较Znode上的版本与客户端数据版本是否一致，一致则更新，否则不更新。
	- watcher
		- 事件类型
			- NodeDataChange事件
			- NodeChildrenChanged事件
			- AuthFailed事件 （授权失败）
	- ACL (Access Control List) - 保障数据安全
		- 相对于Linux的UGO权限机制，更为细粒度。可以针对任意用户和组进行细粒度的权限控制。
		- 权限模式 scheme
			- IP - 通过IP地址粒度进行权限控制
			- Digest - 其类似于“username:password”形式的权限标识来进行权限控制。
		- 授权对象 ID - 不同的scheme下，授权对象是不同的
			- IP - IP地址或IP地址段
			- Digest - 自定义 通常是 username：BASE64（SHA-1(username：password)）
			- world - 只有一个id anyone
			- super - 与Digest一致
7. leader选举
	- leader存在时：通常是一个服务器启动较晚，在其启动之前集群已经可以正常工作，这种情况当其试图选举leader时会被告知leader已经存在。此时与leader建立连接同步状态即可。
	- leader不存在时：
		- 集群启动期间投票
		- leader挂掉 - 运行期间投票
8. 选举算法：
	- 两轮投票
	- 投票内容：server（myid，ZXID）
		- myid - 机器编号
		- ZXID - 事务编号
	- 第一轮投票：每个机器投给自己，把自己的myid和ZXID发出。
	- 第二轮投票：每个机器将受到的所有投票和自己的投票比较。将最大ZXID选票（当选票ZXID相同时，比较myid选择最大myid的选票）做为自己的选票投出。
	- 确定leader：当收到内容一致的选票数超过num=n/2+1则确定此被选者为leader。（需要超过一半的机器能正常工作，整个集群才能正常提供服务）